f.e1 <- -2*sin(pi*k*1/2)*cos(pi*k*x1/2)
f.e2 <- sin(pi*k*x2/2)
f1 = c(f.e1[1],f.e2[1],f.e1[-1], f.e2[-1])
if((k %% 2)==1){
f = list(phi=f1/sqrt(3))
} else {
f.e1 <- (-1)^{k/2}*cos(pi*k*x1/2)
f.e2 <- cos(pi*k*x2/2)
f2 = c(f.e1[1],f.e2[1],f.e1[-1],f.e2[-1])
f <- list(phi=f1,psi=f2/sqrt(3/2))
}
}
return(f)
}
h <- 0.01
graph <- gets_graph_tadpole(h = h)
T_final <- 2
time_step <- 0.01
time_seq <- seq(0, T_final, by = time_step)
# Compute the FEM matrices
graph$compute_fem()
G <- graph$mesh$G
C <- graph$mesh$C
I <- Matrix::Diagonal(nrow(C))
x <- graph$mesh$V[, 1]
y <- graph$mesh$V[, 2]
edge_number <- graph$mesh$VtE[, 1]
pos <- sum(edge_number == 1)+1
order_to_plot <- function(v)return(c(v[1], v[3:pos], v[2], v[(pos+1):length(v)], v[2]))
weights <- graph$mesh$weights
# Initial condition
# U_0 <- 10*exp(-((x-1)^2 + (y)^2))
kappa <- 1
alpha <- 3
beta <- alpha/2
L <- kappa^2*C + G
op <- fractional.operators(L, beta, C, scale.factor = kappa^2, m = 1)
Pl <- op$Pl
Pr <- op$Pr
Ci <- op$Ci
Pr.apply.mult <- function(v){return(Pr.mult(op, v))}
Pl.apply.solve <- function(v){return(Pl.solve(op, v))}
PliC <- apply(Matrix::Diagonal(nrow(C)), 2, Pl.apply.solve) # Pl^-1I
aux <- apply(PliC, 2, Pr.apply.mult) #PrPl^-1I
eig <- eigen(L)
P <- eig$vectors
EIGENVAL <- eig$values
D <- diag(EIGENVAL)
newL <- P %*% D %*% solve(P, Matrix::Diagonal(nrow(C)))
Dk <- diag(EIGENVAL^(-(alpha/2)))
Lk <- (P %*% Dk %*% solve(P, Matrix::Diagonal(nrow(C))))/10
sum((L-newL)^2)
sum((aux - Lk)^2)
aux[1:10,1:10]
Lk[1:10,1:10]
library(rSPDE)
?get.roots
rSPDE::get_roots
rSPDE::get.roots
htmltools::tagList(
xaringanExtra::use_clipboard(
button_text = "<i class=\"fa-solid fa-clipboard\" style=\"color: #00008B\"></i>",
success_text = "<i class=\"fa fa-check\" style=\"color: #90BE6D\"></i>",
error_text = "<i class=\"fa fa-times-circle\" style=\"color: #F94144\"></i>"
),
rmarkdown::html_dependency_font_awesome()
)
# Set seed for reproducibility
set.seed(1982)
# Set global options for all code chunks
knitr::opts_chunk$set(
# Disable messages printed by R code chunks
message = TRUE,
# Disable warnings printed by R code chunks
warning = TRUE,
# Show R code within code chunks in output
echo = TRUE,
# Include both R code and its results in output
include = TRUE,
# Evaluate R code chunks
eval = TRUE,
# Enable caching of R code chunks for faster rendering
cache = FALSE,
# Align figures in the center of the output
fig.align = "center",
# Enable retina display for high-resolution figures
retina = 2,
# Show errors in the output instead of stopping rendering
error = TRUE,
# Do not collapse code and output into a single block
collapse = FALSE
)
# Start the figure counter
fig_count <- 0
# Define the captioner function
captioner <- function(caption) {
fig_count <<- fig_count + 1
paste0("Figure ", fig_count, ": ", caption)
}
# Define the function to truncate a number to two decimal places
truncate_to_two <- function(x) {
floor(x * 100) / 100
}
# install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/testing"), dep=TRUE)
# inla.upgrade(testing = TRUE)
# remotes::install_github("inlabru-org/inlabru", ref = "devel")
# remotes::install_github("davidbolin/rspde", ref = "devel")
# remotes::install_github("davidbolin/metricgraph", ref = "devel")
library(INLA)
library(inlabru)
library(rSPDE)
library(MetricGraph)
library(grateful)
library(plotly)
# Function to build a tadpole graph and create a mesh
gets_graph_tadpole <- function(h){
edge1 <- rbind(c(0,0),c(1,0))
theta <- seq(from=-pi,to=pi,length.out = 100)
edge2 <- cbind(1+1/pi+cos(theta)/pi,sin(theta)/pi)
edges = list(edge1, edge2)
graph <- metric_graph$new(edges = edges)
graph$build_mesh(h = h)
return(graph)
}
# Function to compute the eigenfunctions
tadpole.eig <- function(k,graph){
x1 <- c(0,graph$get_edge_lengths()[1]*graph$mesh$PtE[graph$mesh$PtE[,1]==1,2])
x2 <- c(0,graph$get_edge_lengths()[2]*graph$mesh$PtE[graph$mesh$PtE[,1]==2,2])
if(k==0){
f.e1 <- rep(1,length(x1))
f.e2 <- rep(1,length(x2))
f1 = c(f.e1[1],f.e2[1],f.e1[-1], f.e2[-1])
f = list(phi=f1/sqrt(3))
} else {
f.e1 <- -2*sin(pi*k*1/2)*cos(pi*k*x1/2)
f.e2 <- sin(pi*k*x2/2)
f1 = c(f.e1[1],f.e2[1],f.e1[-1], f.e2[-1])
if((k %% 2)==1){
f = list(phi=f1/sqrt(3))
} else {
f.e1 <- (-1)^{k/2}*cos(pi*k*x1/2)
f.e2 <- cos(pi*k*x2/2)
f2 = c(f.e1[1],f.e2[1],f.e1[-1],f.e2[-1])
f <- list(phi=f1,psi=f2/sqrt(3/2))
}
}
return(f)
}
h <- 0.01
graph <- gets_graph_tadpole(h = h)
T_final <- 2
time_step <- 0.01
time_seq <- seq(0, T_final, by = time_step)
# Compute the FEM matrices
graph$compute_fem()
G <- graph$mesh$G
C <- graph$mesh$C
I <- Matrix::Diagonal(nrow(C))
x <- graph$mesh$V[, 1]
y <- graph$mesh$V[, 2]
edge_number <- graph$mesh$VtE[, 1]
pos <- sum(edge_number == 1)+1
order_to_plot <- function(v)return(c(v[1], v[3:pos], v[2], v[(pos+1):length(v)], v[2]))
weights <- graph$mesh$weights
# Initial condition
# U_0 <- 10*exp(-((x-1)^2 + (y)^2))
kappa <- 1
alpha <- 3
beta <- alpha/2
L <- kappa^2*C + G
op <- fractional.operators(L, beta, C, scale.factor = kappa^2, m = 1)
Pl <- op$Pl
Pr <- op$Pr
Ci <- op$Ci
Ci
sum((L%*%Ci - Ci%*%L)^2)
sum((L%*%C - C%*%L)^2)
C[1:10,1:10]
library(INLA)
get.roots <- function(order, beta, type_interp = "linear") {
if(!(order %in% c(1,2,3,4))) {
stop("order must be one of the values 1,2,3,4.")
}
if (beta > 2) {
beta <- beta - floor(beta - 1)
}
mt <- get(paste0("m", order, "table"))
rb <- rep(0, order + 1)
rc <- rep(0, order)
if(type_interp == "linear"){
if(order == 1) {
rc = approx(mt$beta, mt[[paste0("rc")]], beta)$y
} else {
rc = sapply(1:order, function(i) {
approx(mt$beta, mt[[paste0("rc.", i)]], beta)$y
})
}
rb = sapply(1:(order+1), function(i) {
approx(mt$beta, mt[[paste0("rb.", i)]], xout = beta)$y
})
factor = approx(mt$beta, mt$factor, xout = beta)$y
} else if(type_interp == "spline") {
if(order == 1) {
rc = spline(mt$beta, mt[[paste0("rc")]], xout = beta)$y
} else {
rc = sapply(1:order, function(i) {
spline(mt$beta, mt[[paste0("rc.", i)]], xout = beta)$y
})
}
rb = sapply(1:(order+1), function(i) {
spline(mt$beta, mt[[paste0("rb.", i)]], xout = beta)$y
})
factor = spline(mt$beta, mt$factor, xout = beta)$y
} else {
stop("invalid type. The options are 'linear' and 'spline'.")
}
return(list(rb = rb, rc = rc, factor = factor))
}
get.roots <- function(order, beta, type_interp = "linear") {
if(!(order %in% c(1,2,3,4))) {
stop("order must be one of the values 1,2,3,4.")
}
if (beta > 2) {
beta <- beta - floor(beta - 1)
}
mt <- get(paste0("m", order, "table"))
rb <- rep(0, order + 1)
rc <- rep(0, order)
if(type_interp == "linear"){
if(order == 1) {
rc = approx(mt$beta, mt[[paste0("rc")]], beta)$y
} else {
rc = sapply(1:order, function(i) {
approx(mt$beta, mt[[paste0("rc.", i)]], beta)$y
})
}
rb = sapply(1:(order+1), function(i) {
approx(mt$beta, mt[[paste0("rb.", i)]], xout = beta)$y
})
factor = approx(mt$beta, mt$factor, xout = beta)$y
} else if(type_interp == "spline") {
if(order == 1) {
rc = spline(mt$beta, mt[[paste0("rc")]], xout = beta)$y
} else {
rc = sapply(1:order, function(i) {
spline(mt$beta, mt[[paste0("rc.", i)]], xout = beta)$y
})
}
rb = sapply(1:(order+1), function(i) {
spline(mt$beta, mt[[paste0("rb.", i)]], xout = beta)$y
})
factor = spline(mt$beta, mt$factor, xout = beta)$y
} else {
stop("invalid type. The options are 'linear' and 'spline'.")
}
return(list(rb = rb, rc = rc, factor = factor))
}
roots <- get.roots(order = 2, beta = 1.5, type_interp = "linear")
library(rSPDE)
library(rSPDE)
get.roots <- function(order, beta, type_interp = "linear") {
if(!(order %in% c(1,2,3,4))) {
stop("order must be one of the values 1,2,3,4.")
}
if (beta > 2) {
beta <- beta - floor(beta - 1)
}
mt <- get(paste0("m", order, "table"))
rb <- rep(0, order + 1)
rc <- rep(0, order)
if(type_interp == "linear"){
if(order == 1) {
rc = approx(mt$beta, mt[[paste0("rc")]], beta)$y
} else {
rc = sapply(1:order, function(i) {
approx(mt$beta, mt[[paste0("rc.", i)]], beta)$y
})
}
rb = sapply(1:(order+1), function(i) {
approx(mt$beta, mt[[paste0("rb.", i)]], xout = beta)$y
})
factor = approx(mt$beta, mt$factor, xout = beta)$y
} else if(type_interp == "spline") {
if(order == 1) {
rc = spline(mt$beta, mt[[paste0("rc")]], xout = beta)$y
} else {
rc = sapply(1:order, function(i) {
spline(mt$beta, mt[[paste0("rc.", i)]], xout = beta)$y
})
}
rb = sapply(1:(order+1), function(i) {
spline(mt$beta, mt[[paste0("rb.", i)]], xout = beta)$y
})
factor = spline(mt$beta, mt$factor, xout = beta)$y
} else {
stop("invalid type. The options are 'linear' and 'spline'.")
}
return(list(rb = rb, rc = rc, factor = factor))
}
roots <- get.roots(order = 2, beta = 1.5, type_interp = "linear")
get.roots()
get.roots
roots <- get.roots(order = 2, beta = 1.5, type_interp = "linear")
2^-100
2^-100*2^100
2^-100*2^100
2^-1*2^-1
2^-1*2^-10
2^-11
2^-110
2^-11*2^-10
2^-100*2^-10
rSPDE::m1table
rSPDE:::m2table
get.roots <- function(order, beta, type_interp = "linear") {
if(!(order %in% c(1,2,3,4))) {
stop("order must be one of the values 1,2,3,4.")
}
if (beta > 2) {
beta <- beta - floor(beta - 1)
}
mt <- get(paste0("m", order, "table"))
rb <- rep(0, order + 1)
rc <- rep(0, order)
if(type_interp == "linear"){
if(order == 1) {
rc = approx(mt$beta, mt[[paste0("rc")]], beta)$y
} else {
rc = sapply(1:order, function(i) {
approx(mt$beta, mt[[paste0("rc.", i)]], beta)$y
})
}
rb = sapply(1:(order+1), function(i) {
approx(mt$beta, mt[[paste0("rb.", i)]], xout = beta)$y
})
factor = approx(mt$beta, mt$factor, xout = beta)$y
} else if(type_interp == "spline") {
if(order == 1) {
rc = spline(mt$beta, mt[[paste0("rc")]], xout = beta)$y
} else {
rc = sapply(1:order, function(i) {
spline(mt$beta, mt[[paste0("rc.", i)]], xout = beta)$y
})
}
rb = sapply(1:(order+1), function(i) {
spline(mt$beta, mt[[paste0("rb.", i)]], xout = beta)$y
})
factor = spline(mt$beta, mt$factor, xout = beta)$y
} else {
stop("invalid type. The options are 'linear' and 'spline'.")
}
return(list(rb = rb, rc = rc, factor = factor))
}
m1table <- rSPDE:::m1table
m2table <- rSPDE:::m2table
m3table <- rSPDE:::m3table
m4table <- rSPDE:::m4table
roots <- get.roots(order = 2, beta = 1.5, type_interp = "linear")
View(roots)
View(m4table)
approz
approx()
approx
htmltools::tagList(
xaringanExtra::use_clipboard(
button_text = "<i class=\"fa-solid fa-clipboard\" style=\"color: #00008B\"></i>",
success_text = "<i class=\"fa fa-check\" style=\"color: #90BE6D\"></i>",
error_text = "<i class=\"fa fa-times-circle\" style=\"color: #F94144\"></i>"
),
rmarkdown::html_dependency_font_awesome()
)
# Set seed for reproducibility
set.seed(1982)
# Set global options for all code chunks
knitr::opts_chunk$set(
# Disable messages printed by R code chunks
message = TRUE,
# Disable warnings printed by R code chunks
warning = TRUE,
# Show R code within code chunks in output
echo = TRUE,
# Include both R code and its results in output
include = TRUE,
# Evaluate R code chunks
eval = TRUE,
# Enable caching of R code chunks for faster rendering
cache = FALSE,
# Align figures in the center of the output
fig.align = "center",
# Enable retina display for high-resolution figures
retina = 2,
# Show errors in the output instead of stopping rendering
error = TRUE,
# Do not collapse code and output into a single block
collapse = FALSE
)
# Start the figure counter
fig_count <- 0
# Define the captioner function
captioner <- function(caption) {
fig_count <<- fig_count + 1
paste0("Figure ", fig_count, ": ", caption)
}
# Define the function to truncate a number to two decimal places
truncate_to_two <- function(x) {
floor(x * 100) / 100
}
# install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/testing"), dep=TRUE)
# inla.upgrade(testing = TRUE)
# remotes::install_github("inlabru-org/inlabru", ref = "devel")
# remotes::install_github("davidbolin/rspde", ref = "devel")
# remotes::install_github("davidbolin/metricgraph", ref = "devel")
library(INLA)
library(inlabru)
library(rSPDE)
library(MetricGraph)
library(grateful)
library(plotly)
# Function to build a tadpole graph and create a mesh
gets_graph_tadpole <- function(h){
edge1 <- rbind(c(0,0),c(1,0))
theta <- seq(from=-pi,to=pi,length.out = 100)
edge2 <- cbind(1+1/pi+cos(theta)/pi,sin(theta)/pi)
edges = list(edge1, edge2)
graph <- metric_graph$new(edges = edges)
graph$build_mesh(h = h)
return(graph)
}
# Function to compute the eigenfunctions
tadpole.eig <- function(k,graph){
x1 <- c(0,graph$get_edge_lengths()[1]*graph$mesh$PtE[graph$mesh$PtE[,1]==1,2])
x2 <- c(0,graph$get_edge_lengths()[2]*graph$mesh$PtE[graph$mesh$PtE[,1]==2,2])
if(k==0){
f.e1 <- rep(1,length(x1))
f.e2 <- rep(1,length(x2))
f1 = c(f.e1[1],f.e2[1],f.e1[-1], f.e2[-1])
f = list(phi=f1/sqrt(3))
} else {
f.e1 <- -2*sin(pi*k*1/2)*cos(pi*k*x1/2)
f.e2 <- sin(pi*k*x2/2)
f1 = c(f.e1[1],f.e2[1],f.e1[-1], f.e2[-1])
if((k %% 2)==1){
f = list(phi=f1/sqrt(3))
} else {
f.e1 <- (-1)^{k/2}*cos(pi*k*x1/2)
f.e2 <- cos(pi*k*x2/2)
f2 = c(f.e1[1],f.e2[1],f.e1[-1],f.e2[-1])
f <- list(phi=f1,psi=f2/sqrt(3/2))
}
}
return(f)
}
h <- 0.1
graph <- gets_graph_tadpole(h = h)
T_final <- 2
time_step <- 0.01
time_seq <- seq(0, T_final, by = time_step)
# Compute the FEM matrices
graph$compute_fem()
G <- graph$mesh$G
C <- graph$mesh$C
I <- Matrix::Diagonal(nrow(C))
x <- graph$mesh$V[, 1]
y <- graph$mesh$V[, 2]
edge_number <- graph$mesh$VtE[, 1]
pos <- sum(edge_number == 1)+1
order_to_plot <- function(v)return(c(v[1], v[3:pos], v[2], v[(pos+1):length(v)], v[2]))
weights <- graph$mesh$weights
# Initial condition
# U_0 <- 10*exp(-((x-1)^2 + (y)^2))
kappa <- 1
alpha <- 1
beta <- alpha/2
L <- kappa^2*C + G
op <- fractional.operators(L, beta, C, scale.factor = kappa^2, m = 1)
Pl <- op$Pl
Pr <- op$Pr
Ci <- op$Ci
# Parameters to construct U_0
N_finite <- 4 # choose an even number
adjusted_N_finite <- N_finite + N_finite/2 + 1
EIGENVAL_ALPHA <- NULL
EIGENFUN <- NULL
for (j in 0:N_finite) {
lambda_j_alpha <- (kappa^2 + (j*pi/2)^2)^(alpha/2)
e_j <- tadpole.eig(j,graph)$phi
EIGENVAL_ALPHA <- c(EIGENVAL_ALPHA, lambda_j_alpha)
EIGENFUN <- cbind(EIGENFUN, e_j)
if (j>0 && (j %% 2 == 0)) {
lambda_j_alpha <- (kappa^2 + (j*pi/2)^2)^(alpha/2)
e_j <- tadpole.eig(j,graph)$psi
EIGENVAL_ALPHA <- c(EIGENVAL_ALPHA, lambda_j_alpha)
EIGENFUN <- cbind(EIGENFUN, e_j)
}
}
# Building the initial condition as \sum coeff_j EIGENFUN_j
coeff <- 1*(1:adjusted_N_finite)^-1
coeff[-5] <- 0
# lower_zeroer <- 10  # choose an even number
# adjusted_lower_zeroer <- lower_zeroer + lower_zeroer/2 + 1
# coeff[adjusted_lower_zeroer:adjusted_N_finite] <- 0
U_0 <- EIGENFUN %*% coeff
# Building the true solution as \sum coeff_j EIGENFUN_j e^{-\lambda_j^{\frac{\alpha}{2}}t}
U_true <- matrix(NA, nrow = length(x), ncol = length(time_seq))
for (k in 1:length(time_seq)) {
aux_k <- rep(0, length(x))
for (j in 1:adjusted_N_finite) {
aux_k <- aux_k + exp(-time_seq[k]*EIGENVAL_ALPHA[j])*coeff[j]*EIGENFUN[, j]
}
U_true[, k] <- aux_k
}
C
