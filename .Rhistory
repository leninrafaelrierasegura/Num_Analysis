echo = TRUE,
# Include both R code and its results in output
include = TRUE,
# Evaluate R code chunks
eval = TRUE,
# Enable caching of R code chunks for faster rendering
cache = FALSE,
# Align figures in the center of the output
fig.align = "center",
# Enable retina display for high-resolution figures
retina = 2,
# Show errors in the output instead of stopping rendering
error = TRUE,
# Do not collapse code and output into a single block
collapse = FALSE
)
# inla.upgrade(testing = TRUE)
# remotes::install_github("inlabru-org/inlabru", ref = "devel")
# remotes::install_github("davidbolin/rspde", ref = "devel")
# remotes::install_github("davidbolin/metricgraph", ref = "devel")
library(INLA)
library(inlabru)
library(rSPDE)
library(MetricGraph)
library(grateful)
library(plotly)
# Function to build a tadpole graph and create a mesh
gets_graph_tadpole <- function(h){
edge1 <- rbind(c(0,0),c(1,0))
theta <- seq(from=-pi,to=pi,length.out = 10000)
edge2 <- cbind(1+1/pi+cos(theta)/pi,sin(theta)/pi)
edges = list(edge1, edge2)
graph <- metric_graph$new(edges = edges)
graph$build_mesh(h = h)
return(graph)
}
# Function to compute the eigenfunctions
tadpole.eig <- function(k,graph){
x1 <- c(0,graph$get_edge_lengths()[1]*graph$mesh$PtE[graph$mesh$PtE[,1]==1,2])
x2 <- c(0,graph$get_edge_lengths()[2]*graph$mesh$PtE[graph$mesh$PtE[,1]==2,2])
if(k==0){
f.e1 <- rep(1,length(x1))
f.e2 <- rep(1,length(x2))
f1 = c(f.e1[1],f.e2[1],f.e1[-1], f.e2[-1])
f = list(phi=f1/sqrt(3))
} else {
f.e1 <- -2*sin(pi*k*1/2)*cos(pi*k*x1/2)
f.e2 <- sin(pi*k*x2/2)
f1 = c(f.e1[1],f.e2[1],f.e1[-1], f.e2[-1])
if((k %% 2)==1){
f = list(phi=f1/sqrt(3))
} else {
f.e1 <- (-1)^{k/2}*cos(pi*k*x1/2)
f.e2 <- cos(pi*k*x2/2)
f2 = c(f.e1[1],f.e2[1],f.e1[-1],f.e2[-1])
f <- list(phi=f1,psi=f2/sqrt(3/2))
}
}
return(f)
}
h <- 0.001
graph <- gets_graph_tadpole(h = h)
# Compute the FEM matrices
graph$compute_fem()
x <- graph$mesh$V[, 1]
y <- graph$mesh$V[, 2]
edge_number <- graph$mesh$VtE[, 1]
pos <- sum(edge_number == 1)+1
order_to_plot <- function(v)return(c(v[1], v[3:pos], v[2], v[(pos+1):length(v)], v[2]))
weights <- graph$mesh$weights
kappa <- 1
n_finite <- 20
EIGENVAL <- c()       # initialize empty vector for eigenvalues
EIGENFUN <- NULL       # initialize NULL for eigenfunctions matrix
INDEX <- c()
for (j in 0:n_finite) {
lambda_j <- kappa^2 + (j*pi/2)^2
e_j <- tadpole.eig(j,graph)$phi#/sqrt(1000)
EIGENVAL <- c(EIGENVAL, lambda_j)         # append scalar to vector
EIGENFUN <- cbind(EIGENFUN, e_j)            # append column to matrix
INDEX <- c(INDEX, j)
if (j>0 && (j %% 2 == 0)) {
lambda_j <- kappa^2 + (j*pi/2)^2
e_j <- tadpole.eig(j,graph)$psi#/sqrt(1000)
EIGENVAL <- c(EIGENVAL, lambda_j)         # append scalar to vector
EIGENFUN <- cbind(EIGENFUN, e_j)            # append column to matrix
INDEX <- c(INDEX, j+0.1)
}
}
# Compute inner product matrix
INNER_PRODUCTS <- t(EIGENFUN) %*% (EIGENFUN * weights)
# Plot using image()
image(INNER_PRODUCTS, main = "Inner Product Matrix", col = heat.colors(100), axes = FALSE)
axis(1, at = seq(0, 1, length.out = ncol(INNER_PRODUCTS)), labels = round(INDEX, 2))
axis(2, at = seq(0, 1, length.out = ncol(INNER_PRODUCTS)), labels = round(INDEX, 2))
View(INNER_PRODUCTS)
htmltools::tagList(
xaringanExtra::use_clipboard(
button_text = "<i class=\"fa-solid fa-clipboard\" style=\"color: #00008B\"></i>",
success_text = "<i class=\"fa fa-check\" style=\"color: #90BE6D\"></i>",
error_text = "<i class=\"fa fa-times-circle\" style=\"color: #F94144\"></i>"
),
rmarkdown::html_dependency_font_awesome()
)
# Set seed for reproducibility
set.seed(1982)
# Set global options for all code chunks
knitr::opts_chunk$set(
# Disable messages printed by R code chunks
message = FALSE,
# Disable warnings printed by R code chunks
warning = FALSE,
# Show R code within code chunks in output
echo = TRUE,
# Include both R code and its results in output
include = TRUE,
# Evaluate R code chunks
eval = TRUE,
# Enable caching of R code chunks for faster rendering
cache = FALSE,
# Align figures in the center of the output
fig.align = "center",
# Enable retina display for high-resolution figures
retina = 2,
# Show errors in the output instead of stopping rendering
error = TRUE,
# Do not collapse code and output into a single block
collapse = FALSE
)
# inla.upgrade(testing = TRUE)
# remotes::install_github("inlabru-org/inlabru", ref = "devel")
# remotes::install_github("davidbolin/rspde", ref = "devel")
# remotes::install_github("davidbolin/metricgraph", ref = "devel")
library(INLA)
library(inlabru)
library(rSPDE)
library(MetricGraph)
library(grateful)
library(ggplot2)
library(reshape2)
install.packages("reshape2")
htmltools::tagList(
xaringanExtra::use_clipboard(
button_text = "<i class=\"fa-solid fa-clipboard\" style=\"color: #00008B\"></i>",
success_text = "<i class=\"fa fa-check\" style=\"color: #90BE6D\"></i>",
error_text = "<i class=\"fa fa-times-circle\" style=\"color: #F94144\"></i>"
),
rmarkdown::html_dependency_font_awesome()
)
# Set seed for reproducibility
set.seed(1982)
# Set global options for all code chunks
knitr::opts_chunk$set(
# Disable messages printed by R code chunks
message = FALSE,
# Disable warnings printed by R code chunks
warning = FALSE,
# Show R code within code chunks in output
echo = TRUE,
# Include both R code and its results in output
include = TRUE,
# Evaluate R code chunks
eval = TRUE,
# Enable caching of R code chunks for faster rendering
cache = FALSE,
# Align figures in the center of the output
fig.align = "center",
# Enable retina display for high-resolution figures
retina = 2,
# Show errors in the output instead of stopping rendering
error = TRUE,
# Do not collapse code and output into a single block
collapse = FALSE
)
# inla.upgrade(testing = TRUE)
# remotes::install_github("inlabru-org/inlabru", ref = "devel")
# remotes::install_github("davidbolin/rspde", ref = "devel")
# remotes::install_github("davidbolin/metricgraph", ref = "devel")
library(INLA)
library(inlabru)
library(rSPDE)
library(MetricGraph)
library(grateful)
library(ggplot2)
library(reshape2)
library(plotly)
# Function to build a tadpole graph and create a mesh
gets_graph_tadpole <- function(h){
edge1 <- rbind(c(0,0),c(1,0))
theta <- seq(from=-pi,to=pi,length.out = 10000)
edge2 <- cbind(1+1/pi+cos(theta)/pi,sin(theta)/pi)
edges = list(edge1, edge2)
graph <- metric_graph$new(edges = edges)
graph$build_mesh(h = h)
return(graph)
}
# Function to compute the eigenfunctions
tadpole.eig <- function(k,graph){
x1 <- c(0,graph$get_edge_lengths()[1]*graph$mesh$PtE[graph$mesh$PtE[,1]==1,2])
x2 <- c(0,graph$get_edge_lengths()[2]*graph$mesh$PtE[graph$mesh$PtE[,1]==2,2])
if(k==0){
f.e1 <- rep(1,length(x1))
f.e2 <- rep(1,length(x2))
f1 = c(f.e1[1],f.e2[1],f.e1[-1], f.e2[-1])
f = list(phi=f1/sqrt(3))
} else {
f.e1 <- -2*sin(pi*k*1/2)*cos(pi*k*x1/2)
f.e2 <- sin(pi*k*x2/2)
f1 = c(f.e1[1],f.e2[1],f.e1[-1], f.e2[-1])
if((k %% 2)==1){
f = list(phi=f1/sqrt(3))
} else {
f.e1 <- (-1)^{k/2}*cos(pi*k*x1/2)
f.e2 <- cos(pi*k*x2/2)
f2 = c(f.e1[1],f.e2[1],f.e1[-1],f.e2[-1])
f <- list(phi=f1,psi=f2/sqrt(3/2))
}
}
return(f)
}
h <- 0.001
graph <- gets_graph_tadpole(h = h)
# Compute the FEM matrices
graph$compute_fem()
x <- graph$mesh$V[, 1]
y <- graph$mesh$V[, 2]
edge_number <- graph$mesh$VtE[, 1]
pos <- sum(edge_number == 1)+1
order_to_plot <- function(v)return(c(v[1], v[3:pos], v[2], v[(pos+1):length(v)], v[2]))
weights <- graph$mesh$weights
kappa <- 1
n_finite <- 50
EIGENVAL <- c()       # initialize empty vector for eigenvalues
EIGENFUN <- NULL       # initialize NULL for eigenfunctions matrix
INDEX <- c()
for (j in 0:n_finite) {
lambda_j <- kappa^2 + (j*pi/2)^2
e_j <- tadpole.eig(j,graph)$phi#/sqrt(1000)
EIGENVAL <- c(EIGENVAL, lambda_j)         # append scalar to vector
EIGENFUN <- cbind(EIGENFUN, e_j)            # append column to matrix
INDEX <- c(INDEX, j)
if (j>0 && (j %% 2 == 0)) {
lambda_j <- kappa^2 + (j*pi/2)^2
e_j <- tadpole.eig(j,graph)$psi#/sqrt(1000)
EIGENVAL <- c(EIGENVAL, lambda_j)         # append scalar to vector
EIGENFUN <- cbind(EIGENFUN, e_j)            # append column to matrix
INDEX <- c(INDEX, j+0.1)
}
}
# Compute inner product matrix
INNER_PRODUCTS <- t(EIGENFUN) %*% (EIGENFUN * weights)
# Convert to data frame for ggplot
df <- melt(INNER_PRODUCTS)
colnames(df) <- c("i", "j", "value")
# Add proper labels
df$i <- factor(INDEX[df$i])
df$j <- factor(INDEX[df$j])
# Plot heatmap
ggplot(df, aes(x = i, y = j, fill = value)) +
geom_tile() +
scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0) +
labs(title = "Inner Product Matrix", x = "Index", y = "Index") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90))
heatmap(INNER_PRODUCTS,
Rowv = NA, Colv = NA,
col = heat.colors(100),
scale = "none",
main = "Inner Product Matrix")
htmltools::tagList(
xaringanExtra::use_clipboard(
button_text = "<i class=\"fa-solid fa-clipboard\" style=\"color: #00008B\"></i>",
success_text = "<i class=\"fa fa-check\" style=\"color: #90BE6D\"></i>",
error_text = "<i class=\"fa fa-times-circle\" style=\"color: #F94144\"></i>"
),
rmarkdown::html_dependency_font_awesome()
)
# Set seed for reproducibility
set.seed(1982)
# Set global options for all code chunks
knitr::opts_chunk$set(
# Disable messages printed by R code chunks
message = FALSE,
# Disable warnings printed by R code chunks
warning = FALSE,
# Show R code within code chunks in output
echo = TRUE,
# Include both R code and its results in output
include = TRUE,
# Evaluate R code chunks
eval = TRUE,
# Enable caching of R code chunks for faster rendering
cache = FALSE,
# Align figures in the center of the output
fig.align = "center",
# Enable retina display for high-resolution figures
retina = 2,
# Show errors in the output instead of stopping rendering
error = TRUE,
# Do not collapse code and output into a single block
collapse = FALSE
)
# inla.upgrade(testing = TRUE)
# remotes::install_github("inlabru-org/inlabru", ref = "devel")
# remotes::install_github("davidbolin/rspde", ref = "devel")
# remotes::install_github("davidbolin/metricgraph", ref = "devel")
library(INLA)
library(inlabru)
library(rSPDE)
library(MetricGraph)
library(grateful)
library(ggplot2)
library(reshape2)
library(plotly)
# Function to build a tadpole graph and create a mesh
gets_graph_tadpole <- function(h){
edge1 <- rbind(c(0,0),c(1,0))
theta <- seq(from=-pi,to=pi,length.out = 10000)
edge2 <- cbind(1+1/pi+cos(theta)/pi,sin(theta)/pi)
edges = list(edge1, edge2)
graph <- metric_graph$new(edges = edges)
graph$build_mesh(h = h)
return(graph)
}
# Function to compute the eigenfunctions
tadpole.eig <- function(k,graph){
x1 <- c(0,graph$get_edge_lengths()[1]*graph$mesh$PtE[graph$mesh$PtE[,1]==1,2])
x2 <- c(0,graph$get_edge_lengths()[2]*graph$mesh$PtE[graph$mesh$PtE[,1]==2,2])
if(k==0){
f.e1 <- rep(1,length(x1))
f.e2 <- rep(1,length(x2))
f1 = c(f.e1[1],f.e2[1],f.e1[-1], f.e2[-1])
f = list(phi=f1/sqrt(3))
} else {
f.e1 <- -2*sin(pi*k*1/2)*cos(pi*k*x1/2)
f.e2 <- sin(pi*k*x2/2)
f1 = c(f.e1[1],f.e2[1],f.e1[-1], f.e2[-1])
if((k %% 2)==1){
f = list(phi=f1/sqrt(3))
} else {
f.e1 <- (-1)^{k/2}*cos(pi*k*x1/2)
f.e2 <- cos(pi*k*x2/2)
f2 = c(f.e1[1],f.e2[1],f.e1[-1],f.e2[-1])
f <- list(phi=f1,psi=f2/sqrt(3/2))
}
}
return(f)
}
h <- 0.001
graph <- gets_graph_tadpole(h = h)
# Compute the FEM matrices
graph$compute_fem()
x <- graph$mesh$V[, 1]
y <- graph$mesh$V[, 2]
edge_number <- graph$mesh$VtE[, 1]
pos <- sum(edge_number == 1)+1
order_to_plot <- function(v)return(c(v[1], v[3:pos], v[2], v[(pos+1):length(v)], v[2]))
weights <- graph$mesh$weights
kappa <- 1
n_finite <- 50
EIGENVAL <- c()       # initialize empty vector for eigenvalues
EIGENFUN <- NULL       # initialize NULL for eigenfunctions matrix
INDEX <- c()
for (j in 0:n_finite) {
lambda_j <- kappa^2 + (j*pi/2)^2
e_j <- tadpole.eig(j,graph)$phi#/sqrt(1000)
EIGENVAL <- c(EIGENVAL, lambda_j)         # append scalar to vector
EIGENFUN <- cbind(EIGENFUN, e_j)            # append column to matrix
INDEX <- c(INDEX, j)
if (j>0 && (j %% 2 == 0)) {
lambda_j <- kappa^2 + (j*pi/2)^2
e_j <- tadpole.eig(j,graph)$psi#/sqrt(1000)
EIGENVAL <- c(EIGENVAL, lambda_j)         # append scalar to vector
EIGENFUN <- cbind(EIGENFUN, e_j)            # append column to matrix
INDEX <- c(INDEX, j+0.1)
}
}
# Compute inner product matrix
INNER_PRODUCTS <- t(EIGENFUN) %*% (EIGENFUN * weights)
# Assuming INNER_PRODUCTS is a numeric matrix
plot_ly(
z = INNER_PRODUCTS,
type = "heatmap",
colorscale = "Viridis"  # You can try "Hot", "Jet", etc.
) %>%
layout(
title = "Inner Product Matrix of Eigenfunctions",
xaxis = list(title = "Index"),
yaxis = list(title = "Index")
)
weights
coeff <- sample(1:n_finite, n_finite)
coeff
renv::status()
renv::snapshot()
Y
htmltools::tagList(
xaringanExtra::use_clipboard(
button_text = "<i class=\"fa-solid fa-clipboard\" style=\"color: #00008B\"></i>",
success_text = "<i class=\"fa fa-check\" style=\"color: #90BE6D\"></i>",
error_text = "<i class=\"fa fa-times-circle\" style=\"color: #F94144\"></i>"
),
rmarkdown::html_dependency_font_awesome()
)
# Set seed for reproducibility
set.seed(1982)
# Set global options for all code chunks
knitr::opts_chunk$set(
# Disable messages printed by R code chunks
message = FALSE,
# Disable warnings printed by R code chunks
warning = FALSE,
# Show R code within code chunks in output
echo = TRUE,
# Include both R code and its results in output
include = TRUE,
# Evaluate R code chunks
eval = TRUE,
# Enable caching of R code chunks for faster rendering
cache = FALSE,
# Align figures in the center of the output
fig.align = "center",
# Enable retina display for high-resolution figures
retina = 2,
# Show errors in the output instead of stopping rendering
error = TRUE,
# Do not collapse code and output into a single block
collapse = FALSE
)
# inla.upgrade(testing = TRUE)
# remotes::install_github("inlabru-org/inlabru", ref = "devel")
# remotes::install_github("davidbolin/rspde", ref = "devel")
# remotes::install_github("davidbolin/metricgraph", ref = "devel")
library(INLA)
library(inlabru)
library(rSPDE)
library(MetricGraph)
library(grateful)
library(plotly)
# Function to build a tadpole graph and create a mesh
gets_graph_tadpole <- function(h){
edge1 <- rbind(c(0,0),c(1,0))
theta <- seq(from=-pi,to=pi,length.out = 10000)
edge2 <- cbind(1+1/pi+cos(theta)/pi,sin(theta)/pi)
edges = list(edge1, edge2)
graph <- metric_graph$new(edges = edges)
graph$build_mesh(h = h)
return(graph)
}
# Function to compute the eigenfunctions
tadpole.eig <- function(k,graph){
x1 <- c(0,graph$get_edge_lengths()[1]*graph$mesh$PtE[graph$mesh$PtE[,1]==1,2])
x2 <- c(0,graph$get_edge_lengths()[2]*graph$mesh$PtE[graph$mesh$PtE[,1]==2,2])
if(k==0){
f.e1 <- rep(1,length(x1))
f.e2 <- rep(1,length(x2))
f1 = c(f.e1[1],f.e2[1],f.e1[-1], f.e2[-1])
f = list(phi=f1/sqrt(3))
} else {
f.e1 <- -2*sin(pi*k*1/2)*cos(pi*k*x1/2)
f.e2 <- sin(pi*k*x2/2)
f1 = c(f.e1[1],f.e2[1],f.e1[-1], f.e2[-1])
if((k %% 2)==1){
f = list(phi=f1/sqrt(3))
} else {
f.e1 <- (-1)^{k/2}*cos(pi*k*x1/2)
f.e2 <- cos(pi*k*x2/2)
f2 = c(f.e1[1],f.e2[1],f.e1[-1],f.e2[-1])
f <- list(phi=f1,psi=f2/sqrt(3/2))
}
}
return(f)
}
time_step <- 0.01
T_final <- 2
time_seq <- seq(0, T_final, by = time_step)
h <- 0.01
graph <- gets_graph_tadpole(h = h)
# Compute the FEM matrices
graph$compute_fem()
x <- graph$mesh$V[, 1]
y <- graph$mesh$V[, 2]
edge_number <- graph$mesh$VtE[, 1]
pos <- sum(edge_number == 1)+1
order_to_plot <- function(v)return(c(v[1], v[3:pos], v[2], v[(pos+1):length(v)], v[2]))
weights <- graph$mesh$weights
# Initial condition
U_0 <- 10*exp(-((x-1)^2 + (y)^2))
kappa <- 1
alpha <- 0.51
n_finite <- 10
EIGENVAL <- c()       # initialize empty vector for eigenvalues
EIGENFUN <- NULL       # initialize NULL for eigenfunctions matrix
INDEX <- c()
for (j in 0:n_finite) {
lambda_j <- kappa^2 + (j*pi/2)^2
e_j <- tadpole.eig(j,graph)$phi#/sqrt(1000)
EIGENVAL <- c(EIGENVAL, lambda_j)         # append scalar to vector
EIGENFUN <- cbind(EIGENFUN, e_j)            # append column to matrix
INDEX <- c(INDEX, j)
if (j>0 && (j %% 2 == 0)) {
lambda_j <- kappa^2 + (j*pi/2)^2
e_j <- tadpole.eig(j,graph)$psi#/sqrt(1000)
EIGENVAL <- c(EIGENVAL, lambda_j)         # append scalar to vector
EIGENFUN <- cbind(EIGENFUN, e_j)            # append column to matrix
INDEX <- c(INDEX, j+0.1)
}
}
coeff <- sample(1:n_finite, n_finite+1, replace = TRUE)
coeff <- sample(1:length(INDEX), length(INDEX))
U_0 <- EIGENFUN %*% coeff
gc()
