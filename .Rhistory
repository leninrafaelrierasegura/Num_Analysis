m1table <- rSPDE:::m1table
m2table <- rSPDE:::m2table
m3table <- rSPDE:::m3table
m4table <- rSPDE:::m4table
# install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/testing"), dep=TRUE)
# inla.upgrade(testing = TRUE)
# remotes::install_github("inlabru-org/inlabru", ref = "devel")
# remotes::install_github("davidbolin/rspde", ref = "devel")
# remotes::install_github("davidbolin/metricgraph", ref = "devel")
library(INLA)
library(inlabru)
library(rSPDE)
library(MetricGraph)
library(grateful)
library(plotly)
# For each m and beta, this function returns c_m/b_{m+1} and the roots of rb and rc
my.get.roots <- function(order, beta) {
mt <- get(paste0("m", order, "table"))
rb <- rep(0, order + 1)
rc <- rep(0, order)
if(order == 1) {
rc = approx(mt$beta, mt[[paste0("rc")]], beta)$y
} else {
rc = sapply(1:order, function(i) {
approx(mt$beta, mt[[paste0("rc.", i)]], beta)$y
})
}
rb = sapply(1:(order+1), function(i) {
approx(mt$beta, mt[[paste0("rb.", i)]], xout = beta)$y
})
factor = approx(mt$beta, mt$factor, xout = beta)$y
return(list(rb = rb, rc = rc, factor = factor))
}
# Given the roots, return the polynomial coefficients in increasing order like a+bx+cx^2+...
# So if the output is c(6, -5, 1), that means 6 - 5x + x^2
poly_from_roots <- function(roots) {
coef <- 1
for (r in roots) {
coef <- convolve(coef, c(1, -r), type = "open")
}
return(coef) # returns in increasing order like a+bx+cx^2+...
}
compute_partial_fraction_param <- function(factor, pr_roots, pl_roots, cte) {
pr_coef <- c(0, poly_from_roots(pr_roots)) # in decreasing order like x^n+bx^(n-1)+cx^(n-2)+...
pl_coef <- poly_from_roots(pl_roots) # in decreasing order like x^n+bx^(n-1)+cx^(n-2)+...
# factor_pr_coef <- factor * pr_coef
# pr_plus_pl_coef <- factor_pr_coef + cte * pl_coef
factor_pr_coef <- pr_coef
pr_plus_pl_coef <- factor_pr_coef + cte/factor * pl_coef
res <- gsignal::residue(factor_pr_coef, pr_plus_pl_coef)
return(list(r = res$r, p = res$p, k = res$k)) # in decreasing order like x^n+bx^(n-1)+cx^(n-2)+...
}
my.fractional.operators.frac <- function(L, # kappa^2C + G
beta,
C,
scale.factor, # kappa^2
m = 1,
time_step) {
C <- Matrix::Diagonal(dim(C)[1], rowSums(C)) # lumped
Ci <- Matrix::Diagonal(dim(C)[1], 1 / rowSums(C)) # lumped
I <- Matrix::Diagonal(dim(C)[1])
L <- L / scale.factor # C + G/kappa^2
LCi <- L %*% Ci
if(beta == 1){
return(list(Ci = Ci, C = C, LCi = LCi, L = L, m = m, beta = beta, LHS = C + time_step * L))
} else{
roots <- my.get.roots(m, beta)
poles_rs_k <- compute_partial_fraction_param(roots$factor, roots$rc, roots$rb, time_step)
# Fill list
partial.fraction.factors <- list()
for (i in 1:(m+1)) {
partial.fraction.factors[[i]] <- (LCi - poles_rs_k$p[i] * I)/poles_rs_k$r[i]
}
partial.fraction.factors[[m+2]] <- ifelse(is.null(poles_rs_k$k), 0, poles_rs_k$k) * I
return(list(Ci = Ci, C = C, LCi = LCi, L = L, m = m, beta = beta, partial.fraction.factors = partial.fraction.factors))
}
}
my.solver.frac <- function(obj, v){
beta <- obj$beta
m <- obj$m
C <- obj$C
Ci <- obj$Ci
if (beta == 1){
return(solve(obj$LHS, v))
} else {
partial.fraction.factors <- obj$partial.fraction.factors
#v <- C %*% v
output <- partial.fraction.factors[[m+2]] %*% v
for (i in 1:(m+1)) {
output <- output + solve(partial.fraction.factors[[i]], v)
}
return(Ci %*% output)
}
}
# Function to build a tadpole graph and create a mesh
gets_graph_tadpole <- function(h){
edge1 <- rbind(c(0,0),c(1,0))
theta <- seq(from=-pi,to=pi,length.out = 10000)
edge2 <- cbind(1+1/pi+cos(theta)/pi,sin(theta)/pi)
edges = list(edge1, edge2)
graph <- metric_graph$new(edges = edges)
graph$set_manual_edge_lengths(edge_lengths = c(1,2))
graph$build_mesh(h = h)
return(graph)
}
# Function to compute the eigenfunctions
tadpole.eig <- function(k,graph){
x1 <- c(0,graph$get_edge_lengths()[1]*graph$mesh$PtE[graph$mesh$PtE[,1]==1,2])
x2 <- c(0,graph$get_edge_lengths()[2]*graph$mesh$PtE[graph$mesh$PtE[,1]==2,2])
if(k==0){
f.e1 <- rep(1,length(x1))
f.e2 <- rep(1,length(x2))
f1 = c(f.e1[1],f.e2[1],f.e1[-1], f.e2[-1])
f = list(phi=f1/sqrt(3))
} else {
f.e1 <- -2*sin(pi*k*1/2)*cos(pi*k*x1/2)
f.e2 <- sin(pi*k*x2/2)
f1 = c(f.e1[1],f.e2[1],f.e1[-1], f.e2[-1])
if((k %% 2)==1){
f = list(phi=f1/sqrt(3))
} else {
f.e1 <- (-1)^{k/2}*cos(pi*k*x1/2)
f.e2 <- cos(pi*k*x2/2)
f2 = c(f.e1[1],f.e2[1],f.e1[-1],f.e2[-1])
f <- list(phi=f1,psi=f2/sqrt(3/2))
}
}
return(f)
}
h <- 0.01
graph <- gets_graph_tadpole(h = h)
T_final <- 2
time_step <- 0.01
time_seq <- seq(0, T_final, by = time_step)
# Compute the FEM matrices
graph$compute_fem()
G <- graph$mesh$G
C <- graph$mesh$C
I <- Matrix::Diagonal(nrow(C))
x <- graph$mesh$V[, 1]
y <- graph$mesh$V[, 2]
edge_number <- graph$mesh$VtE[, 1]
pos <- sum(edge_number == 1)+1
order_to_plot <- function(v)return(c(v[1], v[3:pos], v[2], v[(pos+1):length(v)], v[2]))
weights <- graph$mesh$weights
kappa <- 1
alpha <- 0.5 # from 0.5 to 2
m = 1
beta <- alpha/2
L <- kappa^2*C + G
# Parameters to construct U_0
N_finite <- 4 # choose an even number
adjusted_N_finite <- N_finite + N_finite/2 + 1
EIGENVAL_ALPHA <- NULL
EIGENFUN <- NULL
INDEX <- NULL
PHI_OR_PSI <- NULL
for (j in 0:N_finite) {
lambda_j_alpha <- (kappa^2 + (j*pi/2)^2)^(alpha/2)
e_j <- tadpole.eig(j,graph)$phi
EIGENVAL_ALPHA <- c(EIGENVAL_ALPHA, lambda_j_alpha)
EIGENFUN <- cbind(EIGENFUN, e_j)
INDEX <- c(INDEX, j)
PHI_OR_PSI <- c(PHI_OR_PSI, "phi")
if (j>0 && (j %% 2 == 0)) {
lambda_j_alpha <- (kappa^2 + (j*pi/2)^2)^(alpha/2)
e_j <- tadpole.eig(j,graph)$psi
EIGENVAL_ALPHA <- c(EIGENVAL_ALPHA, lambda_j_alpha)
EIGENFUN <- cbind(EIGENFUN, e_j)
INDEX <- c(INDEX, j)
PHI_OR_PSI <- c(PHI_OR_PSI, "psi")
}
}
# Building the initial condition as \sum coeff_j EIGENFUN_j
coeff <- 50*(1:adjusted_N_finite)^-1
coeff[-5] <- 0
U_0 <- EIGENFUN %*% coeff
# Building the true solution as \sum coeff_j EIGENFUN_j e^{-\lambda_j^{\frac{\alpha}{2}}t}
U_true <- matrix(NA, nrow = length(x), ncol = length(time_seq))
for (k in 1:length(time_seq)) {
aux_k <- rep(0, length(x))
for (j in 1:adjusted_N_finite) {
aux_k <- aux_k + exp(-time_seq[k]*EIGENVAL_ALPHA[j])*coeff[j]*EIGENFUN[, j]
}
U_true[, k] <- aux_k
}
c_k <- 10
what_eigenfunction_for_ff <- 7
ff <- function(t){
return(c_k*EIGENFUN[,what_eigenfunction_for_ff]*exp(-t*EIGENVAL_ALPHA[what_eigenfunction_for_ff]))
}
FF_true <- matrix(NA, nrow = length(x), ncol = length(time_seq))
FF_sol_true <- matrix(NA, nrow = length(x), ncol = length(time_seq))
for (k in 1:length(time_seq)) {
FF_true[, k] <- ff(time_seq[k]) # this is the right hand side function
FF_sol_true[, k] <- time_seq[k]*FF_true[, k] # this is the second term in the solution
}
U_true <- U_true + FF_sol_true
graph_to_approx_int <- gets_graph_tadpole(h = 0.001)
loc_finer <- graph_to_approx_int$get_mesh_locations()
A <- graph$fem_basis(loc_finer)
graph_to_approx_int$compute_fem()
C_finer <- graph_to_approx_int$mesh$C
EIGENFUN_FOR_FF <- tadpole.eig(INDEX[what_eigenfunction_for_ff], graph_to_approx_int)
if (PHI_OR_PSI[what_eigenfunction_for_ff] == "phi"){
eigenfun_for_ff <- EIGENFUN_FOR_FF$phi
} else if (PHI_OR_PSI[what_eigenfunction_for_ff] == "psi"){
eigenfun_for_ff <- EIGENFUN_FOR_FF$psi
}
int_basis_eigen <- as.vector(t(as.matrix(eigenfun_for_ff)) %*% C_finer %*% A)
COEF <- c_k*exp(-time_seq*EIGENVAL_ALPHA[what_eigenfunction_for_ff])
FF_approx <- int_basis_eigen %*% t(COEF)
coarse_h <- 0.1
coarse_graph <- gets_graph_tadpole(h = coarse_h)
coarse_A <- coarse_graph$fem_basis(graph$get_mesh_locations())
coarse_time_step <- 0.1
coarse_time_seq <- seq(0, T_final, by = coarse_time_step)
# Compute the FEM matrices
coarse_graph$compute_fem()
coarse_G <- coarse_graph$mesh$G
coarse_C <- coarse_graph$mesh$C
coarse_I <- Matrix::Diagonal(nrow(coarse_C))
coarse_x <- coarse_graph$mesh$V[, 1]
coarse_y <- coarse_graph$mesh$V[, 2]
coarse_edge_number <- coarse_graph$mesh$VtE[, 1]
coarse_pos <- sum(coarse_edge_number == 1)+1
coarse_order_to_plot <- function(v)return(c(v[1], v[3:coarse_pos], v[2], v[(coarse_pos+1):length(v)], v[2]))
coarse_weights <- coarse_graph$mesh$weights
coarse_L <- kappa^2*coarse_C + coarse_G
coarse_U_0 <- t(coarse_A) %*% U_0
coarse_x <- coarse_order_to_plot(coarse_x)
coarse_y <- coarse_order_to_plot(coarse_y)
plot_ly(x = ~order_to_plot(x), y = ~order_to_plot(y), z = ~apply(U_0, 2,order_to_plot)[,1], type = 'scatter3d', mode = 'lines')
plot_ly(x = ~coarse_x, y = ~coarse_y, z = ~apply(coarse_U_0, 2, coarse_order_to_plot)[,1], type = 'scatter3d', mode = 'lines')
htmltools::tagList(
xaringanExtra::use_clipboard(
button_text = "<i class=\"fa-solid fa-clipboard\" style=\"color: #00008B\"></i>",
success_text = "<i class=\"fa fa-check\" style=\"color: #90BE6D\"></i>",
error_text = "<i class=\"fa fa-times-circle\" style=\"color: #F94144\"></i>"
),
rmarkdown::html_dependency_font_awesome()
)
# Set seed for reproducibility
set.seed(1982)
# Set global options for all code chunks
knitr::opts_chunk$set(
# Disable messages printed by R code chunks
message = TRUE,
# Disable warnings printed by R code chunks
warning = TRUE,
# Show R code within code chunks in output
echo = TRUE,
# Include both R code and its results in output
include = TRUE,
# Evaluate R code chunks
eval = TRUE,
# Enable caching of R code chunks for faster rendering
cache = FALSE,
# Align figures in the center of the output
fig.align = "center",
# Enable retina display for high-resolution figures
retina = 2,
# Show errors in the output instead of stopping rendering
error = TRUE,
# Do not collapse code and output into a single block
collapse = FALSE
)
# Start the figure counter
fig_count <- 0
# Define the captioner function
captioner <- function(caption) {
fig_count <<- fig_count + 1
paste0("Figure ", fig_count, ": ", caption)
}
# Define the function to truncate a number to two decimal places
truncate_to_two <- function(x) {
floor(x * 100) / 100
}
m1table <- rSPDE:::m1table
m2table <- rSPDE:::m2table
m3table <- rSPDE:::m3table
m4table <- rSPDE:::m4table
# install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/testing"), dep=TRUE)
# inla.upgrade(testing = TRUE)
# remotes::install_github("inlabru-org/inlabru", ref = "devel")
# remotes::install_github("davidbolin/rspde", ref = "devel")
# remotes::install_github("davidbolin/metricgraph", ref = "devel")
library(INLA)
library(inlabru)
library(rSPDE)
library(MetricGraph)
library(grateful)
library(plotly)
# For each m and beta, this function returns c_m/b_{m+1} and the roots of rb and rc
my.get.roots <- function(order, beta) {
mt <- get(paste0("m", order, "table"))
rb <- rep(0, order + 1)
rc <- rep(0, order)
if(order == 1) {
rc = approx(mt$beta, mt[[paste0("rc")]], beta)$y
} else {
rc = sapply(1:order, function(i) {
approx(mt$beta, mt[[paste0("rc.", i)]], beta)$y
})
}
rb = sapply(1:(order+1), function(i) {
approx(mt$beta, mt[[paste0("rb.", i)]], xout = beta)$y
})
factor = approx(mt$beta, mt$factor, xout = beta)$y
return(list(rb = rb, rc = rc, factor = factor))
}
# Given the roots, return the polynomial coefficients in increasing order like a+bx+cx^2+...
# So if the output is c(6, -5, 1), that means 6 - 5x + x^2
poly_from_roots <- function(roots) {
coef <- 1
for (r in roots) {
coef <- convolve(coef, c(1, -r), type = "open")
}
return(coef) # returns in increasing order like a+bx+cx^2+...
}
compute_partial_fraction_param <- function(factor, pr_roots, pl_roots, cte) {
pr_coef <- c(0, poly_from_roots(pr_roots)) # in decreasing order like x^n+bx^(n-1)+cx^(n-2)+...
pl_coef <- poly_from_roots(pl_roots) # in decreasing order like x^n+bx^(n-1)+cx^(n-2)+...
# factor_pr_coef <- factor * pr_coef
# pr_plus_pl_coef <- factor_pr_coef + cte * pl_coef
factor_pr_coef <- pr_coef
pr_plus_pl_coef <- factor_pr_coef + cte/factor * pl_coef
res <- gsignal::residue(factor_pr_coef, pr_plus_pl_coef)
return(list(r = res$r, p = res$p, k = res$k)) # in decreasing order like x^n+bx^(n-1)+cx^(n-2)+...
}
my.fractional.operators.frac <- function(L, # kappa^2C + G
beta,
C,
scale.factor, # kappa^2
m = 1,
time_step) {
C <- Matrix::Diagonal(dim(C)[1], rowSums(C)) # lumped
Ci <- Matrix::Diagonal(dim(C)[1], 1 / rowSums(C)) # lumped
I <- Matrix::Diagonal(dim(C)[1])
L <- L / scale.factor # C + G/kappa^2
LCi <- L %*% Ci
if(beta == 1){
return(list(Ci = Ci, C = C, LCi = LCi, L = L, m = m, beta = beta, LHS = C + time_step * L))
} else{
roots <- my.get.roots(m, beta)
poles_rs_k <- compute_partial_fraction_param(roots$factor, roots$rc, roots$rb, time_step)
# Fill list
partial.fraction.factors <- list()
for (i in 1:(m+1)) {
partial.fraction.factors[[i]] <- (LCi - poles_rs_k$p[i] * I)/poles_rs_k$r[i]
}
partial.fraction.factors[[m+2]] <- ifelse(is.null(poles_rs_k$k), 0, poles_rs_k$k) * I
return(list(Ci = Ci, C = C, LCi = LCi, L = L, m = m, beta = beta, partial.fraction.factors = partial.fraction.factors))
}
}
my.solver.frac <- function(obj, v){
beta <- obj$beta
m <- obj$m
C <- obj$C
Ci <- obj$Ci
if (beta == 1){
return(solve(obj$LHS, v))
} else {
partial.fraction.factors <- obj$partial.fraction.factors
#v <- C %*% v
output <- partial.fraction.factors[[m+2]] %*% v
for (i in 1:(m+1)) {
output <- output + solve(partial.fraction.factors[[i]], v)
}
return(Ci %*% output)
}
}
# Function to build a tadpole graph and create a mesh
gets_graph_tadpole <- function(h){
edge1 <- rbind(c(0,0),c(1,0))
theta <- seq(from=-pi,to=pi,length.out = 10000)
edge2 <- cbind(1+1/pi+cos(theta)/pi,sin(theta)/pi)
edges = list(edge1, edge2)
graph <- metric_graph$new(edges = edges)
graph$set_manual_edge_lengths(edge_lengths = c(1,2))
graph$build_mesh(h = h)
return(graph)
}
# Function to compute the eigenfunctions
tadpole.eig <- function(k,graph){
x1 <- c(0,graph$get_edge_lengths()[1]*graph$mesh$PtE[graph$mesh$PtE[,1]==1,2])
x2 <- c(0,graph$get_edge_lengths()[2]*graph$mesh$PtE[graph$mesh$PtE[,1]==2,2])
if(k==0){
f.e1 <- rep(1,length(x1))
f.e2 <- rep(1,length(x2))
f1 = c(f.e1[1],f.e2[1],f.e1[-1], f.e2[-1])
f = list(phi=f1/sqrt(3))
} else {
f.e1 <- -2*sin(pi*k*1/2)*cos(pi*k*x1/2)
f.e2 <- sin(pi*k*x2/2)
f1 = c(f.e1[1],f.e2[1],f.e1[-1], f.e2[-1])
if((k %% 2)==1){
f = list(phi=f1/sqrt(3))
} else {
f.e1 <- (-1)^{k/2}*cos(pi*k*x1/2)
f.e2 <- cos(pi*k*x2/2)
f2 = c(f.e1[1],f.e2[1],f.e1[-1],f.e2[-1])
f <- list(phi=f1,psi=f2/sqrt(3/2))
}
}
return(f)
}
h <- 0.01
graph <- gets_graph_tadpole(h = h)
T_final <- 2
time_step <- 0.01
time_seq <- seq(0, T_final, by = time_step)
# Compute the FEM matrices
graph$compute_fem()
G <- graph$mesh$G
C <- graph$mesh$C
I <- Matrix::Diagonal(nrow(C))
x <- graph$mesh$V[, 1]
y <- graph$mesh$V[, 2]
edge_number <- graph$mesh$VtE[, 1]
pos <- sum(edge_number == 1)+1
order_to_plot <- function(v)return(c(v[1], v[3:pos], v[2], v[(pos+1):length(v)], v[2]))
weights <- graph$mesh$weights
kappa <- 1
alpha <- 0.5 # from 0.5 to 2
m = 1
beta <- alpha/2
L <- kappa^2*C + G
# Parameters to construct U_0
N_finite <- 4 # choose an even number
adjusted_N_finite <- N_finite + N_finite/2 + 1
EIGENVAL_ALPHA <- NULL
EIGENFUN <- NULL
INDEX <- NULL
PHI_OR_PSI <- NULL
for (j in 0:N_finite) {
lambda_j_alpha <- (kappa^2 + (j*pi/2)^2)^(alpha/2)
e_j <- tadpole.eig(j,graph)$phi
EIGENVAL_ALPHA <- c(EIGENVAL_ALPHA, lambda_j_alpha)
EIGENFUN <- cbind(EIGENFUN, e_j)
INDEX <- c(INDEX, j)
PHI_OR_PSI <- c(PHI_OR_PSI, "phi")
if (j>0 && (j %% 2 == 0)) {
lambda_j_alpha <- (kappa^2 + (j*pi/2)^2)^(alpha/2)
e_j <- tadpole.eig(j,graph)$psi
EIGENVAL_ALPHA <- c(EIGENVAL_ALPHA, lambda_j_alpha)
EIGENFUN <- cbind(EIGENFUN, e_j)
INDEX <- c(INDEX, j)
PHI_OR_PSI <- c(PHI_OR_PSI, "psi")
}
}
# Building the initial condition as \sum coeff_j EIGENFUN_j
coeff <- 50*(1:adjusted_N_finite)^-1
coeff[-5] <- 0
U_0 <- EIGENFUN %*% coeff
# Building the true solution as \sum coeff_j EIGENFUN_j e^{-\lambda_j^{\frac{\alpha}{2}}t}
U_true <- matrix(NA, nrow = length(x), ncol = length(time_seq))
for (k in 1:length(time_seq)) {
aux_k <- rep(0, length(x))
for (j in 1:adjusted_N_finite) {
aux_k <- aux_k + exp(-time_seq[k]*EIGENVAL_ALPHA[j])*coeff[j]*EIGENFUN[, j]
}
U_true[, k] <- aux_k
}
c_k <- 10
what_eigenfunction_for_ff <- 7
ff <- function(t){
return(c_k*EIGENFUN[,what_eigenfunction_for_ff]*exp(-t*EIGENVAL_ALPHA[what_eigenfunction_for_ff]))
}
FF_true <- matrix(NA, nrow = length(x), ncol = length(time_seq))
FF_sol_true <- matrix(NA, nrow = length(x), ncol = length(time_seq))
for (k in 1:length(time_seq)) {
FF_true[, k] <- ff(time_seq[k]) # this is the right hand side function
FF_sol_true[, k] <- time_seq[k]*FF_true[, k] # this is the second term in the solution
}
U_true <- U_true + FF_sol_true
graph_to_approx_int <- gets_graph_tadpole(h = 0.001)
loc_finer <- graph_to_approx_int$get_mesh_locations()
A <- graph$fem_basis(loc_finer)
graph_to_approx_int$compute_fem()
C_finer <- graph_to_approx_int$mesh$C
EIGENFUN_FOR_FF <- tadpole.eig(INDEX[what_eigenfunction_for_ff], graph_to_approx_int)
if (PHI_OR_PSI[what_eigenfunction_for_ff] == "phi"){
eigenfun_for_ff <- EIGENFUN_FOR_FF$phi
} else if (PHI_OR_PSI[what_eigenfunction_for_ff] == "psi"){
eigenfun_for_ff <- EIGENFUN_FOR_FF$psi
}
int_basis_eigen <- as.vector(t(as.matrix(eigenfun_for_ff)) %*% C_finer %*% A)
COEF <- c_k*exp(-time_seq*EIGENVAL_ALPHA[what_eigenfunction_for_ff])
FF_approx <- int_basis_eigen %*% t(COEF)
coarse_h <- 0.1
coarse_graph <- gets_graph_tadpole(h = coarse_h)
coarse_A <- coarse_graph$fem_basis(graph$get_mesh_locations())
coarse_time_step <- 0.1
coarse_time_seq <- seq(0, T_final, by = coarse_time_step)
# Compute the FEM matrices
coarse_graph$compute_fem()
coarse_G <- coarse_graph$mesh$G
coarse_C <- coarse_graph$mesh$C
coarse_I <- Matrix::Diagonal(nrow(coarse_C))
coarse_x <- coarse_graph$mesh$V[, 1]
coarse_y <- coarse_graph$mesh$V[, 2]
coarse_edge_number <- coarse_graph$mesh$VtE[, 1]
coarse_pos <- sum(coarse_edge_number == 1)+1
coarse_order_to_plot <- function(v)return(c(v[1], v[3:coarse_pos], v[2], v[(coarse_pos+1):length(v)], v[2]))
coarse_weights <- coarse_graph$mesh$weights
coarse_L <- kappa^2*coarse_C + coarse_G
coarse_U_0 <- solve(t(coarse_A) %*% coarse_A, t(coarse_A) %*% U_0)
coarse_x <- coarse_order_to_plot(coarse_x)
coarse_y <- coarse_order_to_plot(coarse_y)
plot_ly(x = ~order_to_plot(x), y = ~order_to_plot(y), z = ~apply(U_0, 2,order_to_plot)[,1], type = 'scatter3d', mode = 'lines')
plot_ly(x = ~coarse_x, y = ~coarse_y, z = ~apply(coarse_U_0, 2, coarse_order_to_plot)[,1], type = 'scatter3d', mode = 'lines')
